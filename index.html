<!doctype html>
<meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
<meta content="ISO-8859-1" http-equiv="encoding">
<html>
    <head>
        <title>66.71 WebGL FrameWork</title>
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
            textarea{ background-color: black; foreground-color: white;}
        </style>
    </head>

    <body onload="initWebGL()">
        <center>
            <div id="contenedor3D">
                <canvas id="my-canvas" width="1280" height="720">
                Your browser does not support the HTML5 canvas element.
                </canvas>
            </div>
        </center>

        <script type="text/javascript" src="js/lib/gl-matrix.js"></script>
        <script type="text/javascript" src="js/lib/dat.gui.min.js"></script>
        <script type="text/javascript" src="js/lib/jquery-2.1.4.min.js"></script>

        <script type="text/javascript" src="js/Light.js"></script>
        <script type="text/javascript" src="js/Transformation.js"></script>

        <script src="js/buffers.js" type="text/javascript"></script>
        <script src="js/shaders.js" type="text/javascript"></script>
        <script src="js/interaction.js" type="text/javascript"></script>

        <script type="text/javascript" src="js/Revolution/revolution.js"></script>
        <script type="text/javascript" src="js/Revolution/Object3D.js"></script>
        <script type="text/javascript" src="js/Revolution/Cylinder.js"></script>
        <script type="text/javascript" src="js/Revolution/Sphere.js"></script>
        <script type="text/javascript" src="js/Revolution/Prism.js"></script>
        <script type="text/javascript" src="js/Revolution/ConvexSweep.js"></script>
        <script type="text/javascript" src="js/Revolution/RevolutionSweep.js"></script>
        <script type="text/javascript" src="js/Revolution/StraightSweep.js"></script>
        <script type="text/javascript" src="js/Revolution/TwistSweep.js"></script>
        <script type="text/javascript" src="js/Revolution/Axis.js"></script>

        <script type="text/javascript" src="js/Bakery/Cake.js"></script>
        <script type="text/javascript" src="js/Bakery/CakeBase.js"></script>
        <script type="text/javascript" src="js/Bakery/CakeRing.js"></script>
        <script type="text/javascript" src="js/Bakery/ConeDecoration.js"></script>
        <script type="text/javascript" src="js/Bakery/BallDecoration.js"></script>
        <script type="text/javascript" src="js/Bakery/FruitDecoration.js"></script>
        <script type="text/javascript" src="js/Bakery/EdgeCylinder.js"></script>
        <script type="text/javascript" src="js/Bakery/EdgePrism.js"></script>
        <script type="text/javascript" src="js/Bakery/Plate.js"></script>
        <script type="text/javascript" src="js/Bakery/Conveyor.js"></script>
        <script type="text/javascript" src="js/Bakery/DecorationMachine.js"></script>
        <script type="text/javascript" src="js/Bakery/DecorationArm.js"></script>
        <script type="text/javascript" src="js/Bakery/EdgeMachine.js"></script>
        <script type="text/javascript" src="js/Bakery/EdgeArm.js"></script>

        <script type="text/javascript" src="js/animations/Animation.js"></script>
        <script type="text/javascript" src="js/animations/CakeAnimations.js"></script>
        <script type="text/javascript" src="js/animations/EdgeAnimations.js"></script>
        <script type="text/javascript" src="js/animations/DecoAnimations.js"></script>
        
        
        <script id="shader-vs" type="x-shader/x-vertex">            
            // Los atributos son caracteristicas propias de cada vertice.
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexColor;
            attribute vec3 aVertexNormal;
            attribute highp vec2 aVertexTexture;
            attribute highp float glossiness;

            // Los uniforms son caracteristicas propias de una etapa de dibujado completa.
            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;
            uniform mat4 uMVMatrix_TI;

            // Los varying toman valor para cada fragmento a partir de la interpolacion
            varying highp vec4 vColor;
            varying highp vec4 vNormal;
            varying highp vec2 vTexture;

            void main(void) {
                // gl_Position es una variable "built-in" de GLSL que es usada para 
                // almacenar la posicion resultante del fragmento.
                gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                vColor = vec4(aVertexColor,1.0);
                vNormal = vec4(aVertexNormal,1.0);
                vTexture = aVertexTexture;
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment">
            varying highp vec4 vColor;
            varying highp vec4 vNormal;

            uniform lowp vec3 I1, I2, I3;
            uniform lowp vec3 Ie1, Ie2, Ie3;
            uniform lowp vec3 L1, L2, L3;

            lowp vec3 n, k, vCamera;
            lowp vec3 buf;

            uniform sampler2D flavor;
            varying highp vec2 vTexture;

            void main(void) {
                n = vec3(vNormal);
                k = vec3(vColor);

                // gl_FragColor es una variable "built-in" de GLSL que es usada para 
                // almacenar el color resultante del fragmento.
                gl_FragColor = vec4(
                    I1*k*(1.0+dot(L1,n)) + Ie1*k*pow(dot(2.0*dot(L1,n)*n - L1, vCamera), 1.0) + 
                        I2*k*(1.0+dot(L2,n)) + Ie2*k*pow(dot(2.0*dot(L2,n)*n - L2, vCamera), 1.0) +
                        I3*k*(1.0+dot(L3,n)) + Ie3*k*pow(dot(2.0*dot(L3,n)*n - L3, vCamera), 1.0)
                    , 1.0);
                return;
                highp vec4 textureColor = texture2D(flavor, vTexture);
                gl_FragColor = vec4(textureColor.rgb, textureColor.a);
            }
        </script>

        <script>
            var gl = null,
                canvas = null,
                glProgram = null,
                FPS = 20,
                scene = new Revolution.Object3D(),
                lights = [
                    new Light(0.02).at([0,25,0]),
                    new Light(0.02).at([25,15,0]),
                    new Light(0.02).at([0,15,25])
                ]

            var mvMatrix = mat4.create();
            var pMatrix = mat4.create();

            var params = {
                cake: {
                    radius: 1,
                    height: 0.7,
                    floors: 3,
                    waveWidth: 0.125,
                    ringTwists: 4,
                    waveWidth: 0.125,
                    decoration: "ball",
                    decorationsCount: 5,
                    edge: "cylinder",
                    edgesCount: 8
                }
            }

            var CAMERA_DEFAULTS = {
                mouse: {
                    down: false,
                    x: 0.0,
                    y: 0.0,
                    prevX: 0.0,
                    prevY: 0.0
                },
                rho: Math.PI/4,     // angle of camera with YZ
                alpha: -Math.PI/4,  // angle of camera with XY
                radius: 30.0,
                translation: [0,0,0],
                perspective: true,
                orthographic: false,
                followCake: false
            }
            var camera = jQuery.extend({}, CAMERA_DEFAULTS)
            
            var datActions = {
                help: function() {
                    alert(
                        "W, S: Zoom in and out\n" +
                        "A, D: Move left and right\n" +
                        "1-7: Select cameras\n" +
                        "DragnDrop: Rotate camera (on perspective view)"
                    )
                },
                setCameraDefaults: function() {
                    camera = jQuery.extend({}, CAMERA_DEFAULTS)
                },
                generateScene: function() {
                    generateCake()
                    generateDecorationMachine()
                    generateEdgeMachine()
                    buildAnimations()
                    Animation.playAll()
                },
                togglePlay: function() {
                    if (this.isPlaying) Animation.pauseAll()
                    else Animation.playAll()
                    this.isPlaying = !this.isPlaying
                },
                isPlaying: true
            }

            var gui = buildDatGUI()


            function generateCake() {
                scene.remove("cake")
                let cake = new Bakery.Cake(params.cake).build()
                cake.translate([0,3.5,-1.5])
                cake.setName("cake")

                scene.add(cake)
            }

            function generateDecorationMachine() {
                scene.remove("decoration machine")
                let machine = new Bakery.DecorationMachine(params.cake.decoration).build()
                machine.translate([0,0,4])
                machine.setName("decoration machine")
                scene.add(machine)
            }

            function generateEdgeMachine() {
                let { edge, height } = params.cake
                scene.remove("edge machine")
                let edgeMachine = new Bakery.EdgeMachine(edge, height).build()
                edgeMachine.translate([0,0,12])
                edgeMachine.setName("edge machine")
                scene.add(edgeMachine)
            }

            function buildAnimations() {
                let decoAnimations = new DecoAnimations(
                    scene.getChild("decoration machine"),
                    params.cake.decorationsCount,
                    5*params.cake.radius/9
                )
                let edgeAnimations = new EdgeAnimations(scene.getChild("edge machine"), params.cake.edgesCount)
                let cakeAnimation = new CakeAnimations(scene.getChild("cake"), decoAnimations, edgeAnimations)
            }

            function buildDatGUI() {
                var gui = new dat.GUI()
                gui.add(datActions, "help").name("Help")
                gui.add(datActions, "setCameraDefaults").name("Reset camera")
                gui.add(datActions, "togglePlay").name("Play/Pause")

                let cakeFolder = gui.addFolder("Cake")
                cakeFolder.add(params.cake, "decoration",
                    {Cones: "cone", Balls: "ball", Fruits: "fruit"}
                ).name("Decoration")
                cakeFolder.add(params.cake, "decorationsCount", 3, 12).name("# Decorations").step(1)
                cakeFolder.add(params.cake, "edge", 
                    {Cylinders: "cylinder", Rectangle: "prism"}
                ).name("Edge")
                cakeFolder.add(params.cake, "edgesCount", 8, 32).name("# Edges").step(1)
                cakeFolder.add(params.cake, "radius", 0.6, 1.5).name("Radius").step(0.1)
                cakeFolder.add(params.cake, "height", 0.3, 2).name("Height").step(0.1)
                cakeFolder.add(params.cake, "floors", 1, 5).name("Floors").step(1)
                cakeFolder.add(params.cake, "ringTwists", 1, 8).name("Ring twists").step(1)
                cakeFolder.add(params.cake, "waveWidth", 0.05, 0.25).name("Wave width").step(0.05)
                cakeFolder.add(datActions, "generateScene").name("Generate")
                return gui
            }

            function setupWebGL() {
                //set the clear color
                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.enable(gl.DEPTH_TEST);                              
                gl.depthFunc(gl.LEQUAL); 
                gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            function buildScene() {
                generateCake()
                generateDecorationMachine()
                generateEdgeMachine()

                var conveyor = new Bakery.Conveyor().build()
                conveyor.translate([0,3.5,0])
                scene.add(conveyor)

                var floor = new Revolution.Prism(40, 0.1, 30).build()
                floor.setColor([0.3,0.3,0.3])
                floor.translate([0,-0.05,5])
                scene.add(floor)

                var wall1 = new Revolution.Prism(0.1, 15, 30).build()
                wall1.translate([-20,7.5,5])
                wall1.setColor([0.7,1,1])
                scene.add(wall1)

                var wall2 = new Revolution.Prism(40, 15, 0.1).build()
                wall2.translate([0,7.5,-10])
                wall2.setColor([0.7,1,1])
                scene.add(wall2)

                buildAnimations()
            }

            function initWebGL() {
                canvas = document.getElementById("my-canvas");  
                try {
                    gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");                    
                } catch(e) {}

                if(gl) {
                    buildScene();
                    setupWebGL();
                    initShaders();
                    setDefaultPerspective()
                    camera.radius = 15
                    setInterval(drawScene, 1000/FPS);
                } else {    
                    alert("Error: Your browser does not appear to support WebGL.");
                }
            }
            
            function rotateCamera() {
                mat4.identity(mvMatrix);
                mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -camera.radius]);
                mat4.rotate(mvMatrix, mvMatrix, camera.rho, [1,0,0])
                mat4.rotate(mvMatrix, mvMatrix, camera.alpha, [0,1,0])
                if (camera.followCake) 
                    camera.translation = revolution.scalar(-1, scene.getChild("cake").transformation.translation)
                mat4.translate(mvMatrix, mvMatrix, camera.translation)
            }

            function drawScene() {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                rotateCamera()
                
                setCamaraBuffers();
                setLightBuffers();
                setUniformLocations();

                setupWebGLBuffers(scene)
                drawVertexGrid(scene);
                
                scene.advance()
            }

        </script>
    </body>
</html>
