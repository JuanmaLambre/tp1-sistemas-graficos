<!doctype html>
<meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type">
<meta content="ISO-8859-1" http-equiv="encoding">
<html>
    <head>
        <title>66.71 WebGL FrameWork</title>
        <style>
            body{ background-color: grey; }
            canvas{ background-color: white; }
            textarea{ background-color: black; foreground-color: white;}
        </style>
    </head>

    <body onload="initWebGL()">
        <center>
            <div id="contenedor3D">
                <canvas id="my-canvas" width="1280" height="720">
                Your browser does not support the HTML5 canvas element.
                </canvas>
            </div>
        </center>

        <script type="text/javascript" src="js/lib/gl-matrix.js"></script>
        <script type="text/javascript" src="js/lib/dat.gui.min.js"></script>
        <script type="text/javascript" src="js/lib/jquery-2.1.4.min.js"></script>

        <script src="js/buffers.js" type="text/javascript"></script>
        <script src="js/shaders.js" type="text/javascript"></script>
        <script src="js/interaction.js" type="text/javascript"></script>

        <script type="text/javascript" src="js/Revolution/revolution.js"></script>
        <script type="text/javascript" src="js/Revolution/Object3D.js"></script>
        <script type="text/javascript" src="js/Revolution/Cylinder.js"></script>
        <script type="text/javascript" src="js/Revolution/Sphere.js"></script>
        <script type="text/javascript" src="js/Revolution/Prism.js"></script>
        <script type="text/javascript" src="js/Revolution/ConvexSweep.js"></script>
        <script type="text/javascript" src="js/Revolution/RevolutionSweep.js"></script>
        <script type="text/javascript" src="js/Revolution/StraightSweep.js"></script>
        <script type="text/javascript" src="js/Revolution/TwistSweep.js"></script>
        <script type="text/javascript" src="js/Revolution/Axis.js"></script>

        <script type="text/javascript" src="js/Bakery/Cake.js"></script>
        <script type="text/javascript" src="js/Bakery/CakeBase.js"></script>
        <script type="text/javascript" src="js/Bakery/CakeRing.js"></script>
        <script type="text/javascript" src="js/Bakery/ConeDecoration.js"></script>
        <script type="text/javascript" src="js/Bakery/BallDecoration.js"></script>
        <script type="text/javascript" src="js/Bakery/FruitDecoration.js"></script>
        <script type="text/javascript" src="js/Bakery/EdgeCylinder.js"></script>
        <script type="text/javascript" src="js/Bakery/EdgePrism.js"></script>
        <script type="text/javascript" src="js/Bakery/Plate.js"></script>
        <script type="text/javascript" src="js/Bakery/Conveyor.js"></script>
        <script type="text/javascript" src="js/Bakery/DecorationMachine.js"></script>
        <script type="text/javascript" src="js/Bakery/DecorationArm.js"></script>
        <script type="text/javascript" src="js/Bakery/EdgeMachine.js"></script>
        <script type="text/javascript" src="js/Bakery/EdgeArm.js"></script>
        
        
        <script id="shader-vs" type="x-shader/x-vertex" src="shaders/default-vs.vert">            
            // Los atributos son caracteristicas propias de cada vertice.
            attribute vec3 aVertexPosition;
            attribute vec3 aVertexColor;
            attribute vec3 aVertexNormal;

            // Los uniforms son caracteristicas propias de una etapa de dibujado completa.
            // Son comunes a todos los vertices involucrados en el dibujado.
            uniform mat4 uMVMatrix;
            uniform mat4 uPMatrix;

            // Los varying son propiedades que toman valor para cada fragmento a partir
            // de interpolar linealmente entre los valores que se les asigna en cada 
            // vertice del poligono al cual pertenecen.
            varying highp vec4 vColor;    
            varying highp vec4 vNormal;    

            void main(void) {
                // gl_Position es una variable "built-in" de GLSL que es usada para 
                // almacenar la posicion resultante del fragmento.
                gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
                vColor = vec4(aVertexColor,1.0);
                vNormal = vec4(aVertexNormal,1.0);
            }
        </script>

        <script id="shader-fs" type="x-shader/x-fragment" src="shaders/default-fs.frag">
            varying highp vec4 vColor;
            varying highp vec4 vNormal;

            highp vec3 ilum;
            highp vec3 norm;
            highp vec3 col;

            void main(void) {
                ilum = vec3(-1.0,1.0,1.0);
                norm = vec3(vNormal);
                col = vec3(vColor);
                // gl_FragColor es una variable "built-in" de GLSL que es usada para 
                // almacenar el color resultante del fragmento.
                // cos(alpha) * vColor, alpha: ilum & vNormal
                gl_FragColor = vec4((max(dot(ilum, norm),0.0)/(length(norm)*length(ilum))) * col, 1.0);
            }
        </script>

        <script>
            var gl = null,
                canvas = null,
                glProgram = null,
                fragmentShader = null,
                vertexShader = null,
                t = 0.0,
                my_grid = null,
                scene = new Revolution.Object3D();

            var mvMatrix = mat4.create();
            var pMatrix = mat4.create();

            var params = {
                cake: {
                    radius: 1,
                    height: 0.7,
                    floors: 3,
                    waveWidth: 0.125,
                    ringTwists: 4,
                    waveWidth: 0.125,
                    decoration: "ball",
                    decorationsCount: 8,
                    edge: "cylinder",
                    edgesCount: 24
                }
            }

            var CAMERA_DEFAULTS = {
                mouse: {
                    down: false,
                    x: 0.0,
                    y: 0.0,
                    prevX: 0.0,
                    prevY: 0.0
                },
                rho: Math.PI/4,     // angle of camera with YZ
                alpha: -Math.PI/4,  // angle of camera with XY
                radius: 30.0,
                translation: [0,0,0],
                perspective: true,
                orthographic: false
            }
            var camera = jQuery.extend({}, CAMERA_DEFAULTS)
            
            var datActions = {
                help: function() {
                    alert(
                        "W, S: Zoom in and out\n" +
                        "A, D: Move left and right\n" +
                        "1-6: Select cameras\n" +
                        "DragnDrop: Rotate camera (on perspective view)"
                    )
                },
                setCameraDefaults: function() {
                    camera = jQuery.extend({}, CAMERA_DEFAULTS)
                }
            }

            var gui = buildDatGUI()
            

            function generateCake() {
                scene.remove("cake")
                let cake = new Bakery.Cake(params.cake).build()
                cake.translate([0,3.5,4])
                cake.setName("cake")
                scene.add(cake)
            }

            function buildDatGUI() {
                var gui = new dat.GUI()
                gui.add(datActions, "help").name("Help")
                gui.add(datActions, "setCameraDefaults").name("Reset camera")

                let cakeFolder = gui.addFolder("Cake")
                cakeFolder.add(params.cake, "decoration",
                    {Cones: "cone", Balls: "ball", Fruits: "fruit"}
                ).name("Decoration")
                cakeFolder.add(params.cake, "decorationsCount", 3, 12).name("# Decorations").step(1)
                cakeFolder.add(params.cake, "edge", 
                    {Cylinders: "cylinder", Rectangle: "prism"}
                ).name("Edge")
                cakeFolder.add(params.cake, "edgesCount", 8, 32).name("# Edges").step(1)
                cakeFolder.add(params.cake, "radius", 0.6, 1.5).name("Radius").step(0.1)
                cakeFolder.add(params.cake, "height", 0.3, 2).name("Height").step(0.1)
                cakeFolder.add(params.cake, "floors", 1, 5).name("Floors").step(1)
                cakeFolder.add(params.cake, "ringTwists", 1, 8).name("Ring twists").step(1)
                cakeFolder.add(params.cake, "waveWidth", 0.05, 0.25).name("Wave width").step(0.05)
                cakeFolder.add(window, "generateCake").name("Generate")
                return gui
            }

            function setupWebGL() {
                //set the clear color
                gl.clearColor(0.1, 0.1, 0.2, 1.0);     
                gl.enable(gl.DEPTH_TEST);                              
                gl.depthFunc(gl.LEQUAL); 
                gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            
            function buildScene() {
                generateCake()

                var conveyor = new Bakery.Conveyor().build()
                conveyor.translate([0,3.5,0])
                scene.add(conveyor)

                var floor = new Revolution.Prism(40, 0.1, 30).build()
                floor.setColor([0.3,0.3,0.3])
                floor.translate([0,-0.05,5])
                scene.add(floor)

                var wall1 = new Revolution.Prism(0.1, 10, 30).build()
                wall1.translate([-20,5,5])
                wall1.setColor([0.9,0.9,0.9])
                scene.add(wall1)

                var wall2 = new Revolution.Prism(40, 10, 0.1).build()
                wall2.translate([0,5,-10])
                wall2.setColor([0.9,0.9,0.9])
                scene.add(wall2)

                var decorationMachine = new Bakery.DecorationMachine().build()
                decorationMachine.translate([0,0,4])
                scene.add(decorationMachine)

                var edgeMachine = new Bakery.EdgeMachine().build()
                edgeMachine.translate([0,0,12])
                scene.add(edgeMachine)
            }

            function initWebGL() {
                canvas = document.getElementById("my-canvas");  
                try {
                    gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");                    
                } catch(e) {}

                if(gl) {
                    buildScene();
                    setupWebGL();
                    initShaders();
                    setupWebGLBuffers(scene);
                    setDefaultPerspective()
                    setInterval(drawScene, 10);
                } else {    
                    alert("Error: Your browser does not appear to support WebGL.");
                }
            }
            
            function rotateCamera() {
                mat4.identity(mvMatrix);
                mat4.translate(mvMatrix, mvMatrix, [0.0, 0.0, -camera.radius]);
                mat4.rotate(mvMatrix, mvMatrix, camera.rho, [1,0,0])
                mat4.rotate(mvMatrix, mvMatrix, camera.alpha, [0,1,0])
                mat4.translate(mvMatrix, mvMatrix, camera.translation)
            }

            function drawScene() {
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                var u_proj_matrix = gl.getUniformLocation(glProgram, "uPMatrix");
                
                // Preparamos una matriz P
                gl.uniformMatrix4fv(u_proj_matrix, false, pMatrix);
                var u_model_view_matrix = gl.getUniformLocation(glProgram, "uMVMatrix");
                
                // Preparamos una matriz de modelo+vista.
                rotateCamera()
                //mat4.rotate(mvMatrix, mvMatrix, t, [0.0, 1.0, 0.0]);
                t = t + 0.01;
                
                gl.uniformMatrix4fv(u_model_view_matrix, false, mvMatrix);
                //scene.rotate(0.01, [0,1,0])
                //scene.advance(0.01)
                setupWebGLBuffers(scene)
                drawVertexGrid(scene);
            }

        </script>
    </body>
</html>
